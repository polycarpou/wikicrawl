
require 'pp'
require 'ap'

maze = [["█","█","█","█"," "," ","█","█","█"," "," "," ","█","█"," "," "," "," ","█"," ","█","█","█","█"," "," ","█","█","█"," "," "," "," "," "," ","█","█"," ","█"," "],
        ["█","█","█","█"," "," ","█","█"," "," ","█"," "," "," "," "," ","█"," "," "," ","█","█","█","█"," "," ","█"," "," "," "," "," ","█","█"," "," ","█","█","█"," "],
        ["█"," "," "," "," "," ","█"," "," ","█","█","█","█","█"," "," ","█","█","█"," ","█","█","█","█"," "," ","█"," ","█"," ","█","█","█","█"," "," "," "," "," "," "],
        ["█"," ","█","█"," "," "," "," ","█","█","█","█","█","█"," "," ","█","█","█"," ","█","█","█","█"," "," ","█"," ","█"," ","█"," ","█","█"," ",""," "," ","█"," "],
        ["█"," ","█","█"," ","█","█"," "," "," ","█"," "," ","█"," "," ","█","█","█"," ","█","█","█","█"," "," "," "," ","█","█","█"," ","█","█"," "," "," "," ","█"," "],
        ["█"," ","█","█"," ","█","█","█","█"," "," "," "," "," "," "," ","█","█","█"," ","█"," "," "," "," "," ","█"," ","█"," "," "," ","█","█"," "," ","█","█","█"," "],
        ["█"," ","█","█"," "," ","█","█","█","█","█","█","█","█"," "," ","█"," "," "," ","█"," ","█","█"," "," ","█"," ","█"," "," "," ","█","█","█","█","█"," ","█"," "],
        ["█"," "," ","█","█"," "," "," ","█","█","█","█","█","█"," "," "," "," ","█"," "," "," ","█","█"," "," ","█","█","█"," "," "," ","█","█"," "," "," "," ","█"," "],
        ["█","█"," ","█","█","█","█"," "," "," ","█","█","█","█","█"," ","█","█","█","█","█","█","█","█"," "," ","█","█","█"," "," "," ","█"," "," "," "," ","█","█"," "],
        [" "," "," ","█"," "," ","█","█","█","█","█","█","█","█","█","█","█","█","█"," ","█","█","█","█"," "," ","█"," "," "," "," "," "," "," "," "," "," "," "," "," "],
        ["█","█","█","█"," "," ","█","█","█"," "," "," ","█","█"," "," "," "," ","█"," ","█","█","█","█"," "," ","█","█","█"," "," "," "," "," "," ","█","█"," ","█"," "],
        ["█","█","█","█"," "," ","█","█"," "," ","█"," "," "," "," "," ","█"," "," "," ","█","█","█","█"," "," ","█"," "," "," "," "," ","█","█"," "," ","█","█","█"," "],
        ["█"," "," "," "," "," ","█"," "," ","█","█","█","█","█"," "," ","█","█","█"," ","█","█","█","█"," "," ","█"," ","█"," ","█","█","█","█"," "," "," "," "," "," "],
        ["█"," ","█","█"," "," "," "," ","█","█","█","█","█","█"," "," ","█","█","█"," ","█","█","█","█"," "," ","█"," ","█"," ","█","*","█","█"," "," "," "," ","█"," "],
        ["█"," ","█","█"," ","█","█"," "," "," ","█"," "," ","█"," "," ","█","█","█"," ","█","█","█","█"," "," "," "," ","█","█","█"," ","█","█"," "," "," "," ","█"," "],
        ["█"," ","█","█"," ","█","█","█","█"," "," "," "," "," "," "," ","█","█","█"," ","█"," "," "," "," "," ","█"," ","█"," "," "," ","█","█"," "," ","█","█","█"," "],
        ["█"," ","█","█"," "," ","█","█","█","█","█","█","█","█"," "," ","█"," "," "," ","█"," ","█","█"," "," ","█"," ","█"," "," "," ","█","█","█","█","█"," ","█"," "],
        ["█"," "," ","█","█"," "," "," ","█","█","█","█","█","█"," "," "," "," ","█"," "," "," ","█","█"," "," ","█","█","█"," "," "," ","█","█"," "," "," "," ","█"," "],
        ["█","█"," ","█","█","█","█"," "," "," ","█","█","█","█","█"," ","█","█","█","█","█","█","█","█"," "," ","█","█","█"," "," "," ","█"," "," "," "," ","█","█"," "],
        [" "," "," ","█"," "," ","█","█","█","█","█","█","█","█","█","█","█","█","█"," ","█","█","█","█"," "," ","█"," "," "," "," "," "," "," "," "," "," "," "," "," "]

      ]
class MazeSolver
  attr_accessor :maze, :path, :setV, :queueQ
  
  def initialize(maze)
    @maze = maze
  end

  def for_print
    self.maze.each do |row|
      row.each do |box|
        print box
      end
      puts
    end
  end

  def maze_path(short_path)
    short_path.each do |point|
      unless point == "start"
        x = point[0]
        y = point[1]
        self.maze[x][y] = "o"
      end
    end
    for_print
  end

  def find_previous(point)
    path.each do |connect|
      return connect[1] if connect[0]==point
    end
  end


  def backtrack(end_point)
    point = end_point
    short = []
    until point == "start"
      point = find_previous(point)
      short << point
    end
    short
  end

  def blocked?(location)
    self.maze[location[0]][location[1]] == "█"? true : false
  end

  def neighbours(location)
    x,y = location[0],location[1]
    output = [[x-1,y],[x+1,y],[x,y+1],[x,y-1]]
    output.delete_if do |coordinates| 
      x,y = coordinates[0],coordinates[1]
      x <0 || y <0 || x > maze.length-1 || y >maze[0].length-1 
    end
  end

  def add_to_arrays(point, previous="start")
    queueQ << point
    setV << point
    path << [point,previous]
  end
  
  def bfs (v,looking_for)
    self.queueQ = []
    self.setV = []
    self.path = []

    add_to_arrays(v)
     
    while !queueQ.empty?
      t = queueQ.shift
      u = neighbours(t)
      u.each do |coordinates|
        if !setV.include?(coordinates) and !blocked?(coordinates)
          add_to_arrays(coordinates,t)
          if maze[coordinates[0]][coordinates[1]] == looking_for
            puts "found what im looking for!"
            back_path =  backtrack(coordinates)
            maze_path(back_path)
            return coordinates
          end
        end
      end
    end
    puts "Could not find the gem =("
  end
end

new_maze = MazeSolver.new(maze)
system("clear")
new_maze.for_print
sleep 5
system("clear")
new_maze.bfs([9,0],"*")
